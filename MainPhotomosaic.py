#!/usr/bin/env python
"""
Description:
The project is making a photometric. This means taking one photo and making it with thousands of smaller
photos based on color in that area. We are doing this by first collecting the photos urls and getting the most
prominent color in that photo as a whole (????) then we will store it into a dictionary (image url, color, and used#)
once that is completed I will iterate over the based image 8 pixels at a time and then find the image that matches
the color in the base and then start sticking the photos together.

Additional Tools:
    BeautifulSoup4
        $ pip install beautifulsoup4
    OpenCV
        $ pip install opencv

Running:
    $ python photomosaics.py

TODO:
Find the photo DB without water marks but also allow web crawling
Do a better URL validation

Honor Code:
On my honor, I have not given, nor received, nor witnessed any unauthorized assistance on this work.
    I worked on this assignment alone, using only this semester's course materials.

Other Sources:
 https://docs.python.org/2/library/heapq.html
 https://stackoverflow.com/questions/3019909/using-an-index-to-get-an-item-python
 https://pypi.python.org/pypi/python-resize-image
 https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory
 https://stackoverflow.com/questions/33689705/how-to-compare-values-in-tuples-in-a-list


@author: Eduardo "Eddy" Verde & David Maldonado
@author email: everde@rollins.edu & dmalsonado@rollins.edu
"""

from __future__ import print_function
import cv2
import numpy as np
from PIL import Image
from bs4 import BeautifulSoup
import urllib.request as urllib2
from urllib import request
import cv2
import heapq
import numpy as np
import glob, os

# External Resource for creating our image database
import json

from ImageDB import image_db_scrapper


def base_image_processing():
    # setup the output image information
    output_dims = (2500, 2500)
    output_image = Image.new("RGB", output_dims)
    # set the initial x and y coordinates to the beginning of the image
    x = 0
    y = 0

    # determine the path where the image text files are located
    filepath = "C:\\Users\\Nzxt\\Desktop\\project2\\"
    # open the file path with the list of tuples from a text file generated by the other program
    f = open("C:\\Users\\Nzxt\\Desktop\\project2\\image_tuples.txt")

    # create an empty list
    tuple_list = []
    # append each tuple to the list
    for line in f:
        tup = eval(line)
        tuple_list.append(tup)
    # create a list of image names from a text file generated by the other program
    name_list = open("C:\\Users\\Nzxt\\Desktop\\project2\\image_names.txt").readlines()

    # read in the main image to be mosaiced
    mosaic_in = cv2.imread("C:\\Users\\Nzxt\\Desktop\\project2\\test\\mos_image\\mosaic_test.jpg")
    mosaic_in = np.array(mosaic_in)
    # determine the size of the mosaic image
    rows, cols, colors = mosaic_in.shape

    # loop through the image
    for i in range(rows):
        for j in range(cols):
            # look at the current pixel
            current_pixel = mosaic_in[i, j]
            # find the tuple with the minimum distance from the current pixel
            next_image = min(tuple_list,
                             key=lambda c: (c[0] - current_pixel[0]) ** 2 + (c[1] - current_pixel[1]) ** 2 + (c[2] -
                                                                                                              current_pixel[
                                                                                                                  2]) ** 2)
            # get the index of the tuple from the list
            next_image_index = tuple_list.index(next_image)
            # set the tuple index to the same as the one in the name list
            next_image_name = name_list[next_image_index]
            # remove the newline character
            next_image_name = next_image_name.strip()
            # open the image to be used as part of the mosaic
            the_image = Image.open(next_image_name)
            # resize the image to 25x25
            the_image = the_image.resize((25, 25))
            # paste the image in it's spot
            output_image.paste(the_image, (x, y))
            # move through the image based on the size of the image being used
            if x >= 2474:
                x = 0
                y = y + 25
            else:
                x = x + 25
    # save the final image
    output_image.save("C:\\Users\\Nzxt\\Desktop\\project2\\test\\mos_image\\mosaic_test_output.jpg")


if __name__ == '__main__':
    # Introduction, this is what you need to do and what page to search.
    print("Welcome to Photomosaic Application!\n"
          "Before we proceed on please make sure you have a photo\n"
          "save in the same directory as this file and name it 'base.jpg'.\n"
          "Once that is complete make sure you are using the following\n"
          "website for the images. If you do not have a site a default one will\n"
          "be used. Good Luck and Have Fun!\n\n"
          "Website for Images: https://depositphotos.com/\n"
          "Example: https://depositphotos.com/search/space.html\n"
          "Type \"None\" if you want default else enter url:")

    # Getting user input and validating it. If there are an error we will default to a traveling image database.
    src = input()
    if src.upper() == "NONE":
        src = "https://depositphotos.com/search/traveling.html"
    if len(src) <= 23:
        print("URL is invalid, using default")
        src = "https://depositphotos.com/search/traveling.html"

    # This is checking if the database is already created in the image_db directory to reduce the time of collecting
    # images each time. You need to have at least one in the directory to work
    # TODO: Need to figure out how to keep the keys and values the same, but also only analyze the the four corners
    print("Checking if Database already exist.")
    search_file_name = src[33:-5]
    db_exist = False
    for file in os.listdir("./image_db"):
        if file == (search_file_name + ".txt"):
            print("Database Exist, Let's Create a Mosaic")
            db_exist = True

    if not db_exist:
        print("Getting Started with the Processing")
        images = image_db_scrapper(src, search_file_name)
        # temp_images = list(images.keys())
        print("Processing Complete! Let's Make a Mosaic!")


    base = cv2.imread("base.jpg")
    base = cv2.resize(base, (900, 900))
    cv2.imwrite("base.jpg", base)
    base = cv2.imread("base.jpg")

    # We are reading the images from text file.
    db_images = json.load(open("./image_db/"+search_file_name+".txt"))
        # base_image_processing(images, base)
        #
        # pixel = cv2.imread("file.jpg")
        # cv2.imshow("file.jpg", pixel)
        # cv2.waitKey(0)
        # cv2.destroyAllWindows()


# POSSIBILE TODOS
# TODO: Have the user input photo size and tile size
# TODO: Have the images rotate around a square to then put into an image.
# TODO: